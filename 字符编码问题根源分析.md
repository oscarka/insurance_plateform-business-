# 字符编码问题根源分析

## 一、问题发现

### 当前MySQL连接字符集配置

```
character_set_client:     latin1  ❌ (应该是 utf8mb4)
character_set_connection: latin1  ❌ (应该是 utf8mb4)
character_set_results:    latin1  ❌ (应该是 utf8mb4)
character_set_database:   utf8mb4 ✅
character_set_server:     utf8mb4 ✅
```

### 数据存储问题

- **status字段的HEX值**：`C3A5C290C2AFC3A7E2809DC2A8`（错误的编码）
- **正确的UTF-8 HEX值**：`E590AFE794A8`（"启用"的正确编码）

**问题**：数据在插入时被当作 `latin1` 处理，导致存储错误。

---

## 二、问题根源

### 1. 连接池字符集设置不生效

虽然代码中有：
```javascript
pool.on('connection', (connection) => {
  connection.query('SET NAMES utf8mb4 COLLATE utf8mb4_unicode_ci');
});
```

但可能：
- 事件触发时机不对
- 或者连接池复用了旧连接
- 或者需要在每次查询前都设置

### 2. 数据插入时的编码问题

如果插入数据时连接字符集是 `latin1`，MySQL会：
1. 将UTF-8字符串当作latin1解释
2. 转换成错误的字节序列存储
3. 即使表是utf8mb4，数据也已经损坏

---

## 三、解决方案

### 方案1：修复连接池配置（推荐）

在连接池创建时明确设置字符集，并确保每次连接都正确设置。

### 方案2：修复已存储的错误数据

需要将错误编码的数据转换回正确的UTF-8。

### 方案3：重新插入数据

删除错误数据，用正确的编码重新插入。

---

## 四、为什么会出现这个问题？

1. **MySQL默认连接字符集**：某些MySQL配置默认使用 `latin1`
2. **连接池复用**：连接池可能复用了未正确设置字符集的连接
3. **数据插入时机**：可能在连接池事件设置之前就插入了数据
4. **Docker MySQL配置**：Docker中的MySQL可能没有正确配置默认字符集

---

## 五、最佳实践

1. **连接池配置**：在创建连接池时明确设置 `charset: 'utf8mb4'`
2. **连接后设置**：在每次获取连接后立即设置字符集
3. **数据库配置**：确保MySQL服务器默认字符集是 `utf8mb4`
4. **数据验证**：插入数据后验证编码是否正确

