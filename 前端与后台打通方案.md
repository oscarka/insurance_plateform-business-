# 前端客户端与后台配置系统打通方案

## 一、打通目标

将前端客户端的方案选择和数据展示与后台配置系统完全打通，实现：
1. **动态产品选择**：从后台获取产品列表
2. **动态方案选择**：从后台获取方案列表
3. **动态责任配置**：从后台获取责任和保额选项
4. **动态保费计算**：调用后台API计算保费
5. **数据一致性**：前端提交的数据结构与数据库设计一致

---

## 二、已创建的文件

### 1. API服务层
- `src/services/api.ts` - 前端API封装，连接后台系统

### 2. 自定义Hook
- `src/hooks/useProductPlans.ts` - 获取产品和方案数据的Hook

### 3. 动态组件
- `src/components/PlanSelectionDynamic.tsx` - 动态方案选择组件（替代硬编码版本）

---

## 三、数据流程

### 3.1 产品选择流程

```
用户进入投保页面
    ↓
调用 getProducts() API
    ↓
显示产品列表（从后台配置系统获取）
    ↓
用户选择产品
    ↓
调用 getPlans(productId) API
    ↓
显示方案列表（从后台配置系统获取）
```

### 3.2 方案选择流程

```
用户选择方案
    ↓
调用 getPlanLiabilities(planId) API
    ↓
显示方案的责任配置和保额选项（从后台配置系统获取）
    ↓
用户选择责任和保额
    ↓
调用 calculatePremium() API
    ↓
显示计算后的保费（根据后台费率表计算）
```

### 3.3 提交投保流程

```
用户填写完整信息
    ↓
调用 createApplication() API
    ↓
数据结构：
{
  company_info: {...},           // 企业信息
  product_id: 1,                // 产品ID
  plan_instances: [             // 方案实例
    {
      plan_id: 1,               // 方案ID（从后台获取）
      plan_name: "方案一",       // 方案名称
      job_class: "1~3类",        // 用户选择的职业类别
      duration: "1年",           // 用户选择的保障时间
      insured_count: 10,        // 被保人数
      liability_selections: [    // 用户选择的责任和保额
        {
          liability_id: 1,
          coverage_amount: "30万",
          unit: "元"
        }
      ]
    }
  ]
}
    ↓
保存到数据库（applications、application_plans、plan_instance_liabilities表）
```

---

## 四、需要修改的现有代码

### 4.1 修改 NewPolicy.tsx

**当前问题**：
- 产品信息硬编码
- 方案选择硬编码
- 责任选项硬编码
- 保费计算硬编码

**修改方案**：
1. 使用 `PlanSelectionDynamic` 组件替代硬编码的 `PlanSelection`
2. 或者修改现有的 `PlanSelection` 组件，集成API调用

### 4.2 修改保费计算逻辑

**当前代码**（硬编码）：
```typescript
const calculatePlanPrice = (plan: PlanConfig) => {
  let base = 81;
  const jobClassFactors = { '1~3类': 1, '4类': 2.5, '5类': 3.5 };
  const deathFactors = { '10万': 1, '30万': 1.8, '50万': 2.5 };
  // ...
  return Math.round(price);
};
```

**修改后**（调用API）：
```typescript
const handleCalculatePremium = async (plan: PlanConfig) => {
  const result = await calculatePremium({
    product_id: selectedProductId,
    plan_id: plan.plan_id,
    liability_selections: [...],
    job_class: plan.jobClass,
    insured_count: plan.insuredCount,
  });
  return result.premium_per_person;
};
```

---

## 五、数据结构映射

### 5.1 前端 PlanConfig → 后端数据结构

**前端 PlanConfig**：
```typescript
interface PlanConfig {
  id: string;              // 前端临时ID
  name: string;            // 方案名称
  jobClass: string;        // 职业类别
  insuredCount: number;    // 被保人数
  deathBenefit: string;    // 意外身故保额
  medicalBenefit: string;  // 医疗费用保额
  dailyHospital: string;   // 住院津贴
  duration: string;        // 保障时间
  // ...
}
```

**后端数据结构**：
```typescript
// application_plans 表
{
  plan_id: number;         // 方案ID（关联product_plans）
  plan_name: string;       // 方案名称
  job_class: string;       // 用户选择的职业类别
  duration: string;        // 用户选择的保障时间
  insured_count: number;   // 被保人数
}

// plan_instance_liabilities 表
[
  {
    liability_id: number;      // 责任ID
    coverage_amount: string;   // 用户选择的保额
    coverage_value: number;     // 保额数值
    unit: string;               // 单位
  }
]
```

### 5.2 数据转换函数

```typescript
// 将前端PlanConfig转换为后端数据结构
const convertPlanToBackend = (
  plan: PlanConfig,
  planId: number,
  planLiabilities: PlanLiability[]
): {
  plan_instance: any;
  liability_selections: any[];
} => {
  const liabilitySelections = planLiabilities.map((liability) => {
    let coverageAmount = '';
    if (liability.liability_name.includes('意外身故')) {
      coverageAmount = plan.deathBenefit;
    } else if (liability.liability_name.includes('医疗费用')) {
      coverageAmount = plan.medicalBenefit;
    } else if (liability.liability_name.includes('住院津贴')) {
      coverageAmount = plan.dailyHospital;
    }

    return {
      liability_id: liability.liability_id,
      coverage_amount: coverageAmount,
      coverage_value: parseCoverageValue(coverageAmount),
      unit: liability.unit,
    };
  });

  return {
    plan_instance: {
      plan_id: planId,
      plan_name: plan.name,
      job_class: plan.jobClass,
      duration: plan.duration,
      insured_count: plan.insuredCount,
    },
    liability_selections: liabilitySelections,
  };
};
```

---

## 六、实施步骤

### 步骤1：后端API开发

需要实现以下API接口：

1. **GET /api/products** - 获取产品列表
2. **GET /api/products/:id/plans** - 获取产品下的方案列表
3. **GET /api/plans/:id/liabilities** - 获取方案的责任配置
4. **POST /api/premium/calculate** - 计算保费
5. **POST /api/applications** - 创建投保单

### 步骤2：前端集成

1. **替换硬编码组件**：
   - 在 `NewPolicy.tsx` 中使用 `PlanSelectionDynamic` 组件
   - 或者修改现有的 `PlanSelection` 组件

2. **集成API调用**：
   - 使用 `useProductPlans` Hook 获取数据
   - 使用 `calculatePremium` API 计算保费
   - 使用 `createApplication` API 提交投保

3. **数据转换**：
   - 将前端数据结构转换为后端数据结构
   - 确保数据格式符合数据库设计

### 步骤3：测试验证

1. **功能测试**：
   - 测试产品选择
   - 测试方案选择
   - 测试责任配置
   - 测试保费计算
   - 测试提交投保

2. **数据验证**：
   - 验证提交的数据结构
   - 验证数据库中的数据
   - 验证数据一致性

---

## 七、关键代码示例

### 7.1 使用动态方案选择组件

```typescript
// NewPolicy.tsx
import PlanSelectionDynamic from '../components/PlanSelectionDynamic';

// 替换原有的 PlanSelection 组件
{currentStep === 1 && (
  <PlanSelectionDynamic
    plans={plans}
    setPlans={setPlans}
    companyInfo={companyInfo}
    setCompanyInfo={setCompanyInfo}
    onNext={() => setCurrentStep(2)}
  />
)}
```

### 7.2 提交投保数据

```typescript
// 提交投保
const handleSubmit = async () => {
  const applicationData = {
    company_info: {
      name: companyInfo.name,
      credit_code: companyInfo.creditCode,
      // ...
    },
    product_id: selectedProductId,
    plan_instances: plans.map((plan) => {
      const planId = selectedPlanIds[plan.id];
      const liabilities = planLiabilities[planId] || [];
      
      return {
        plan_id: planId,
        plan_name: plan.name,
        job_class: plan.jobClass,
        duration: plan.duration,
        insured_count: plan.insuredCount,
        liability_selections: convertLiabilities(plan, liabilities),
      };
    }),
    effective_date: '2025-01-01',
    expiry_date: '2026-01-01',
  };

  await createApplication(applicationData);
};
```

---

## 八、优势

### 8.1 数据一致性

- 前端展示的数据来自后台配置系统
- 确保用户看到的数据与后台配置一致
- 避免前后端数据不一致的问题

### 8.2 灵活配置

- 后台可以随时调整产品和方案配置
- 前端自动获取最新配置
- 无需修改前端代码

### 8.3 保费准确性

- 保费计算基于后台费率表
- 确保保费计算的准确性
- 支持复杂的费率规则

### 8.4 易于维护

- 配置集中在后台管理
- 前端只负责展示和交互
- 降低维护成本

---

## 九、注意事项

1. **API错误处理**：需要处理API调用失败的情况
2. **加载状态**：需要显示数据加载状态
3. **数据缓存**：可以考虑缓存产品列表等不常变化的数据
4. **数据验证**：前端需要验证用户输入的数据
5. **兼容性**：需要兼容现有的数据格式

---

## 十、下一步

1. **开发后端API**：实现上述API接口
2. **集成前端组件**：使用动态组件替换硬编码组件
3. **测试验证**：测试整个流程
4. **优化体验**：优化加载速度和用户体验

