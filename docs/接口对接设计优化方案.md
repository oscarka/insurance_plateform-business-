# 接口对接设计优化方案

## 一、当前设计的问题

### 1.1 当前设计的问题

**当前设计**：
- `channels` 表：渠道配置
- `api_field_mappings` 表：字段映射（每个保司每个接口需要配置很多条记录）
- `underwriting_intercept_rules` 表：拦截规则（每个保司需要配置很多条规则）
- `data_validation_rules` 表：数据校验规则

**问题**：
1. **配置繁琐**：新增一个保司，需要在多个表中配置很多条记录
2. **维护困难**：字段映射、规则等分散在多个表中，难以管理
3. **不够灵活**：表结构固定，保司的差异配置需要创建很多记录
4. **对接慢**：无法快速对接新保司

---

## 二、优化方案设计

### 2.1 核心思路

**目标**：
- 表结构相对固定
- 通过读取保司的接口配置文件就能快速对接
- 保司的差异配置通过JSON存储，而不是分散在多个表中

**设计原则**：
1. **最小化表结构**：只保留必要的核心表
2. **配置JSON化**：字段映射、拦截规则等存储在JSON字段中
3. **快速对接**：新增保司只需插入一条配置记录
4. **灵活扩展**：JSON结构可以灵活扩展，适应不同保司的需求

---

## 二、优化后的表设计

### 2.1 保司接口配置表（insurance_api_configs）

**设计目的**：统一存储保司的接口配置，所有差异配置都在JSON字段中。

**为什么这样设计**：
- **一个保司一条记录**：新增保司只需插入一条记录
- **配置JSON化**：字段映射、拦截规则、校验规则等都存储在JSON字段中
- **快速对接**：通过配置文件导入，一条记录就能完成对接
- **灵活扩展**：JSON结构可以灵活扩展，适应不同保司的需求

**字段说明**：

| 字段名 | 类型 | 说明 | 是否必填 |
|--------|------|------|----------|
| config_id | BIGINT | 配置ID（主键，自增） | 是 |
| company_id | BIGINT | 保司ID（外键） | 是 |
| company_code | VARCHAR(50) | 保司代码（唯一） | 是 |
| channel_code | VARCHAR(50) | 渠道代码（如：LEXUAN） | 是 |
| api_base_url | VARCHAR(200) | 接口基础地址 | 是 |
| api_version | VARCHAR(20) | 接口版本 | 是 |
| app_id | VARCHAR(100) | 应用ID | 是 |
| app_secret | VARCHAR(200) | 应用密钥（加密存储） | 是 |
| environment | VARCHAR(20) | 环境（test/production） | 是 |
| **api_config_json** | TEXT | **接口配置JSON（包含所有接口的地址、方法等）** | 是 |
| **field_mapping_json** | TEXT | **字段映射JSON（系统字段 → 保司字段的映射）** | 是 |
| **intercept_rules_json** | TEXT | **拦截规则JSON（承保前的校验规则）** | 否 |
| **validation_rules_json** | TEXT | **数据校验规则JSON（字段级别的校验）** | 否 |
| config_source | VARCHAR(100) | 配置来源（配置文件路径或导入批次） | 否 |
| status | VARCHAR(20) | 状态（启用/禁用） | 是 |
| created_at | DATETIME | 创建时间 | 是 |
| updated_at | DATETIME | 更新时间 | 是 |

**JSON结构示例**：

#### api_config_json 结构：
```json
{
  "underwriting": {
    "url": "/api/underwriting",
    "method": "POST",
    "timeout": 30000,
    "retry": 3
  },
  "issuance": {
    "url": "/api/issuance",
    "method": "POST",
    "timeout": 30000
  },
  "endorsement": {
    "url": "/api/endorsement",
    "method": "POST"
  },
  "query": {
    "url": "/api/query",
    "method": "GET"
  }
}
```

#### field_mapping_json 结构：
```json
{
  "underwriting": {
    "application_no": "proposalNo",
    "company_name": "applicantName",
    "credit_code": "applicantIdNo",
    "effective_date": {
      "field": "startDate",
      "format": "YYYY-MM-DD"
    },
    "total_premium": {
      "field": "premium",
      "format": "decimal",
      "precision": 2
    }
  },
  "issuance": {
    "application_no": "proposalNo",
    "policy_no": "policyNo"
  }
}
```

#### intercept_rules_json 结构：
```json
{
  "underwriting": [
    {
      "rule_name": "被保人数限制",
      "check_field": "insured_count",
      "check_operator": "between",
      "check_value": [1, 100],
      "error_code": "E001",
      "error_message": "被保人数必须在1-100人之间",
      "priority": 1
    },
    {
      "rule_name": "保费范围检查",
      "check_field": "total_premium",
      "check_operator": ">=",
      "check_value": 1000,
      "error_code": "E002",
      "error_message": "保费不能低于1000元",
      "priority": 2
    }
  ]
}
```

#### validation_rules_json 结构：
```json
{
  "credit_code": {
    "pattern": "^[0-9A-HJ-NPQRTUWXY]{2}\\d{6}[0-9A-HJ-NPQRTUWXY]{10}$",
    "error_message": "统一社会信用代码格式不正确"
  },
  "phone": {
    "pattern": "^1[3-9]\\d{9}$",
    "error_message": "手机号格式不正确"
  },
  "id_number": {
    "pattern": "^[1-9]\\d{5}(18|19|20)\\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\\d|3[01])\\d{3}[0-9Xx]$",
    "error_message": "身份证号格式不正确"
  }
}
```

---

### 2.2 接口调用日志表（insurance_api_logs）

**保持不变**，用于记录接口调用日志。

---

### 2.3 接口任务表（insurance_api_tasks）

**保持不变**，用于管理异步任务。

---

### 2.4 删除的表

**可以删除的表**：
- ~~`channels` 表~~（合并到 `insurance_api_configs`）
- ~~`api_field_mappings` 表~~（合并到 `field_mapping_json`）
- ~~`underwriting_intercept_rules` 表~~（合并到 `intercept_rules_json`）
- ~~`data_validation_rules` 表~~（合并到 `validation_rules_json`）

---

## 三、优化后的对接流程

### 3.1 新增保司对接流程

**步骤1：准备配置文件**
```json
{
  "company_code": "LIBO",
  "channel_code": "LEXUAN",
  "api_base_url": "https://api.libo.com",
  "api_version": "v1",
  "app_id": "xxx",
  "app_secret": "xxx",
  "api_config": {
    "underwriting": { "url": "/api/underwriting", "method": "POST" },
    "issuance": { "url": "/api/issuance", "method": "POST" }
  },
  "field_mapping": {
    "underwriting": {
      "application_no": "proposalNo",
      "company_name": "applicantName"
    }
  },
  "intercept_rules": {
    "underwriting": [
      {
        "rule_name": "被保人数限制",
        "check_field": "insured_count",
        "check_operator": "between",
        "check_value": [1, 100]
      }
    ]
  }
}
```

**步骤2：导入配置**
- 系统读取配置文件
- 插入一条 `insurance_api_configs` 记录
- 所有配置都在JSON字段中

**步骤3：完成对接**
- 无需在多个表中配置
- 一条记录完成对接

---

### 3.2 接口调用流程

**步骤1：获取配置**
```sql
SELECT * FROM insurance_api_configs 
WHERE company_code = 'LIBO' AND status = '启用'
```

**步骤2：解析JSON配置**
- 解析 `api_config_json` 获取接口地址
- 解析 `field_mapping_json` 进行字段映射
- 解析 `intercept_rules_json` 进行规则检查
- 解析 `validation_rules_json` 进行数据校验

**步骤3：调用接口**
- 根据配置调用保司接口
- 记录日志

---

## 四、优化方案的优势

### 4.1 快速对接

**当前设计**：
- 新增保司需要在4个表中配置
- 字段映射可能需要配置几十条记录
- 拦截规则可能需要配置几十条记录
- 总计可能需要配置上百条记录

**优化后**：
- 新增保司只需插入1条记录
- 所有配置都在JSON字段中
- 通过配置文件导入，一键完成

### 4.2 表结构简单

**当前设计**：
- 4-5个配置表
- 表之间有关联关系
- 查询需要关联多个表

**优化后**：
- 1个核心配置表
- 无关联关系
- 查询简单

### 4.3 灵活扩展

**当前设计**：
- 表结构固定，新增字段需要修改表结构
- 不同保司的差异配置需要创建很多记录

**优化后**：
- JSON结构灵活，可以扩展
- 不同保司的差异配置都在JSON中
- 无需修改表结构

### 4.4 配置管理

**当前设计**：
- 配置分散在多个表中
- 难以统一管理和导出

**优化后**：
- 配置集中在一条记录中
- 可以导出为JSON配置文件
- 便于版本管理和回滚

---

## 五、JSON配置的缺点和解决方案

### 5.1 缺点

1. **查询不便**：JSON字段查询不如关系表方便
2. **索引限制**：JSON字段索引支持有限
3. **数据校验**：JSON结构需要程序层面校验

### 5.2 解决方案

1. **查询优化**：
   - 常用查询字段（如company_code）建立索引
   - JSON字段主要用于配置读取，不用于复杂查询
   - 需要查询时，可以解析JSON到内存中处理

2. **数据校验**：
   - 配置文件导入时，校验JSON结构
   - 使用JSON Schema定义配置结构
   - 程序层面校验配置完整性

3. **配置管理**：
   - 配置文件版本管理
   - 配置变更记录
   - 配置回滚机制

---

## 六、推荐方案

### 方案A：完全JSON化（推荐）

**表结构**：
- `insurance_api_configs`：保司接口配置表（所有配置在JSON中）
- `insurance_api_logs`：接口调用日志表
- `insurance_api_tasks`：接口任务表

**优点**：
- 表结构最简单
- 对接最快
- 配置最灵活

**缺点**：
- JSON查询不便（但配置主要用于读取，影响不大）

### 方案B：混合方案

**表结构**：
- `insurance_api_configs`：保司接口配置表（基础配置 + JSON配置）
- `insurance_api_logs`：接口调用日志表
- `insurance_api_tasks`：接口任务表
- `data_validation_rules`：数据校验规则表（通用规则，不区分保司）

**优点**：
- 通用规则用表存储，便于查询和管理
- 保司差异配置用JSON存储，灵活

**缺点**：
- 表结构稍复杂
- 需要区分通用规则和保司特定规则

---

## 七、建议

**推荐方案A（完全JSON化）**，原因：
1. **符合你的需求**：表结构固定，通过配置文件快速对接
2. **最简单**：只需1个配置表
3. **最灵活**：JSON可以适应各种保司的差异
4. **对接最快**：一条记录完成对接

**如果担心JSON查询问题**：
- 配置主要用于读取，不是频繁查询
- 常用字段（company_code、channel_code）建立索引
- 复杂查询可以在程序层面处理

---

## 八、配置文件格式建议

### 8.1 YAML格式（推荐）

```yaml
company_code: LIBO
channel_code: LEXUAN
api_base_url: https://api.libo.com
api_version: v1
app_id: xxx
app_secret: xxx

api_config:
  underwriting:
    url: /api/underwriting
    method: POST
    timeout: 30000
  issuance:
    url: /api/issuance
    method: POST

field_mapping:
  underwriting:
    application_no: proposalNo
    company_name: applicantName
    credit_code: applicantIdNo

intercept_rules:
  underwriting:
    - rule_name: 被保人数限制
      check_field: insured_count
      check_operator: between
      check_value: [1, 100]
```

### 8.2 JSON格式

```json
{
  "company_code": "LIBO",
  "channel_code": "LEXUAN",
  "api_config": { ... },
  "field_mapping": { ... },
  "intercept_rules": { ... }
}
```

---

## 九、总结

**优化后的设计**：
- **1个核心配置表**：`insurance_api_configs`
- **配置JSON化**：字段映射、拦截规则等都在JSON中
- **快速对接**：新增保司只需插入1条记录
- **灵活扩展**：JSON结构可以适应各种保司的差异

**对接流程**：
1. 准备配置文件（YAML或JSON）
2. 导入配置，插入1条记录
3. 完成对接，可以调用接口

这样的设计是否符合你的需求？

